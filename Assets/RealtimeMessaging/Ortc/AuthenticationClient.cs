// -------------------------------------
//  Domain		: IBT / Realtime.co
//  Author		: Nicholas Ventimiglia
//  Product		: Messaging and Storage
//  Published	: 2014
//  -------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using Realtime.Http;
using Realtime.Tasks;

namespace Realtime.Messaging.Ortc
{
    /// <summary>
    /// The channel permission.
    /// </summary>
    public enum ChannelPermissions
    {
        /// <summary>
        /// Read permission
        /// </summary>
        Read = 'r',

        /// <summary>
        /// Read and Write permission
        /// </summary>
        Write = 'w',

        /// <summary>
        /// Presence permission
        /// </summary>
        Presence = 'p'
    }

    /// <summary>
    /// ORTC server side API that contains ORTC factories as plug-ins.
    /// </summary>
    public class AuthenticationClient
    {
        private static HttpServiceClient _client;
        static HttpServiceClient HttpClient
        {
            get
            {
                if (_client == null)
                {
                    _client = new HttpServiceClient();

                    _client.ContentType = "application/x-www-form-urlencoded";
                }

                return _client;
            }
        }


        #region Post Authentication

        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">Authentication Token which is generated by the application server, for instance a unique session ID.</param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static Task<bool> PostAuthenticationAsync(string url, bool isCluster, string authenticationToken, bool authenticationTokenIsPrivate,
                                              string applicationKey, int timeToLive, string privateKey, Dictionary<string, ChannelPermissions> permissions)
        {
            var multiPermissions = new Dictionary<string, List<ChannelPermissions>>();

            foreach (var permission in permissions)
            {
                var permissionList = new List<ChannelPermissions> { permission.Value };

                multiPermissions.Add(permission.Key, permissionList);
            }

            return PostAuthenticationAsync(url, isCluster, authenticationToken, authenticationTokenIsPrivate, applicationKey, timeToLive, privateKey, multiPermissions);
        }

        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">Authentication Token which is generated by the application server, for instance a unique session ID.</param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static Task<bool> PostAuthenticationAsync(string url, bool isCluster, string authenticationToken, bool authenticationTokenIsPrivate,
                                              string applicationKey, int timeToLive, string privateKey, Dictionary<string, List<ChannelPermissions>> permissions)
        {

            return Task.Run(() => PostAuthentication(url, isCluster, authenticationToken, authenticationTokenIsPrivate, applicationKey, timeToLive, privateKey, permissions));

        }


        /// <summary>
        /// Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">Authentication Token which is generated by the application server, for instance a unique session ID.</param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static bool PostAuthentication(string url, bool isCluster, string authenticationToken, bool authenticationTokenIsPrivate,
                                              string applicationKey, int timeToLive, string privateKey, Dictionary<string, List<ChannelPermissions>> permissions)
        {
            #region Sanity Checks

            if (String.IsNullOrEmpty(url))
            {
                throw new OrtcException(OrtcExceptionReason.InvalidArguments, "URL is null or empty.");
            }
            if (String.IsNullOrEmpty(applicationKey))
            {
                throw new OrtcException(OrtcExceptionReason.InvalidArguments, "Application Key is null or empty.");
            }
            if (String.IsNullOrEmpty(authenticationToken))
            {
                throw new OrtcException(OrtcExceptionReason.InvalidArguments, "Authentication Token is null or empty.");
            }
            if (String.IsNullOrEmpty(privateKey))
            {
                throw new OrtcException(OrtcExceptionReason.InvalidArguments, "Private Key is null or empty.");
            }
            if (permissions != null && permissions.Count == 0)
            {
                throw new OrtcException(OrtcExceptionReason.InvalidArguments, "No permissions set.");
            }

            #endregion

            var connectionUrl = url;

            if (isCluster)
            {
                connectionUrl = ClusterClient.GetClusterServerWithRetry(url, applicationKey);
            }

            connectionUrl = connectionUrl[connectionUrl.Length -1] == '/' ? connectionUrl : connectionUrl + "/";


            var postParameters = String.Format("AT={0}&PVT={1}&AK={2}&TTL={3}&PK={4}", authenticationToken, authenticationTokenIsPrivate ? 1 : 0, applicationKey, timeToLive, privateKey);

            if (permissions != null && permissions.Count > 0)
            {
                postParameters += String.Format("&TP={0}", permissions.Count);
                foreach (var permission in permissions)
                {
                    var permissionItemText = String.Format("{0}=", permission.Key);
                    var list = new List<ChannelPermissions>(permission.Value);
                    foreach (var permissionItemValue in list)
                    {
                        permissionItemText += ((char)permissionItemValue).ToString(CultureInfo.InvariantCulture);
                    }

                    postParameters += String.Format("&{0}", permissionItemText);
                }
            }

            var hTask = HttpClient.PostAsync(String.Format("{0}authenticate", connectionUrl), postParameters);

            hTask.Wait();

            if (hTask.IsFaulted)
                throw hTask.Exception;


            if (hTask.StatusCode == HttpStatusCode.Unauthorized)
                throw new OrtcException(OrtcExceptionReason.Unauthorized, String.Format("Unable to connect to the authentication server {0}.", connectionUrl));


            return hTask.IsSuccess;
        }

        #endregion
    }
}
